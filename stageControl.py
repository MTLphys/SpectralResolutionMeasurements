"""
This is the internal wrapper for handling Stage controll call backs 

Generated By Matthew Larson on November 8th 2023
"""

import dearpygui.dearpygui as dpg 
import serial.tools.list_ports as lport
import time as t 
import re
import sys
import numpy as np 
import matplotlib.pyplot as plt 


this = sys.modules[__name__]
stages = {'t3ref':1,'t13':2,'t12':3, 'z':4}#stage names vs indices
conversion = {
                't3ref': {
                    'fs':43.6476698639934,
                    'ps':43647.6698639934,
                    'um':145.635555555556,
                    'mm':145635.555555556,
                    'ct':1,
                    'fs/s':43.6476698639934,
                    'ps/s':43647.6698639934,
                    'um/s':145.635555555556,
                    'mm/s':145635.555555556,
                    'ct/s':1},
                't13': {
                    'fs':9.09705341041977,
                    'ps':9097.05341041977,
                    'um':30.3533827,
                    'mm':30353.3827,
                    'ct':1,
                    'fs/s':9.09705341041977,
                    'ps/s':9097.05341041977,
                    'um/s':30.3533827,
                    'mm/s':30353.3827,
                    'ct/s':1},
                't12': {
                    'fs':9.09705341041977,
                    'ps':9097.05341041977,
                    'um':30.3533827,
                    'mm':30353.3827,
                    'ct':1,
                    'fs/s':9.09705341041977,
                    'ps/s':9097.05341041977,
                    'um/s':30.3533827,
                    'mm/s':30353.3827,
                    'ct/s':1},
                'z': {
                    'fs':0.598,
                    'ps':598.0 ,
                    'um':2.0,
                    'mm':2000.0,
                    'ct':1,
                    'fs/s':0.598,
                    'ps/s':598.0,
                    'um/s':30.3533827,
                    'mm/s':2000.0,
                    'ct/s':1}
              }

this.dev = None 
#time and distance to stage count conversion factors as listed in stage manuals 
def initialize_stageControl(device):
    if (this.dev is None):
        this.dev = device
    else: 
        msg = "stageControl Already initialized"
        raise RuntimeError(msg)

def populatePorts():
    """retrieve available ports and return their base names ie 'com'
    return: 
        list (containing available ports)
    """
    portlist = []
    for cmport in lport.comports():
        portlist.append(cmport.name)
    return portlist
        



def connectDevice(sender,data,userdata):
    """Attempt to connect to the device of the given port names for instance 'com 1'
    Args: 
        sender(dpg object): the calling function
        data(list): the data sent in from the sender
        userdata (list):the data sent in from the  
    returns:
        0
    
    """
    try:
        port = dpg.get_value(userdata)
        this.dev.port=port
        this.dev.open()
    except:
        try:
            this.dev.close()
            raise ConnectionError('connection failed')
        except:
            raise ConnectionError('disconnect failed on startup') 



def tryCatchRW(command):
    """Attempt to write to device then read any returned information 
    error handling to close device in case of issues
    Args: 
        dev (serial obj): the serial object for connecting to the driver system
        command(str): a standard string containing a SCPI command  
    """
    try:
        #write command to serial 
        this.dev.write(command.encode())
        line=[]
        i=0
        #read response from serial device
        while(line==[]):
            i+=1
            line.append(this.dev.readline())
            if(i>10):
                line.append(' ')
        return line 
    except:
        #handle exceptions 
        this.dev.close()
        raise InterruptedError('error encountered during read/write sequence')

def closeConnect():
    """upon window close disconnect from serial device"""
    this.dev.close()
    print('device connection closed')
    

def tryCatchW(command):
    """Attempt to write to device then read any returned information 
    error handling to close device in case of issues
    Args: 
        dev (serial obj): the serial object for connecting to the driver system
        command (str): a standard string containing a SCPI command  
    """
    try:
        #write command to serial device
        this.dev.write(command.encode())
        return 0
    except:
        this.dev.close()
        raise RuntimeError('error in write sequence please restart program')



def stageSelection(stagename):
    """set the current stage in use
    Args: 
        dev (serial obj): The serial object for connecting to the 
        stagename (str): the name of the stage to be called
    
    """ 
    cmd = 'AXIS '+str(stages[stagename])+"\n"
    tryCatchW(cmd)
    
    
def waitformotion():
    """idle while waiting for device motion to complete
    """
    status =1
    statuscount= 0
    while (statuscount<5.0):
        cmd= "MOT:COND?\n"
        status = tryCatchRW(cmd)
        if len(re.findall(r'\d+', str(status)))>0:
            status=float(re.findall(r'\d+', str(status))[0])
        if(status ==0.0):
            statuscount+=1
        t.sleep(.001)
    return 0 

def moveTo(dest):
    """tell the object to move to a location then wait for motion finish

    Args:
        dest (double) : The location +/- to which the stage will move  
    """
    cmd = 'TARG '+str(dest)+"\n"
    tryCatchW(cmd)
    waitformotion()
    
def setSpeed(speed):
    """Set the speed for the device
    Args:
        speed (double): the set move speed
    """
    cmd = 'MVEL '+str(speed)+"\n"
    tryCatchW(cmd)

def zero():
    """zero device location 
    """
    cmd = 'AXIS:POS 0\n'
    tryCatchW(cmd)
    
def callPosition():
    """ask active stage for current position
    Returns:
        _str_: a string discription of the device position 
    """
    cmd = "Axis:POS?\n"
    position = tryCatchRW(cmd)
    return position
def zeroStage(sender,data,userdata):
    """Set stage position to new home position 
    Args:
        sender(dpg object): the calling function
        data(list): the data sent in from the sender 
        userdata (list):the data sent in from the  [position,sstatus,stage]
    """
    stage = dpg.get_value(userdata[2])
    stageSelection(stage)
    dpg.set_value(userdata[1],"Stage status: Zeroing")
    zero()
    dpg.set_value(userdata[0],'Current Position: 0')
    
    dpg.set_value(userdata[1],"Stage status: inactive")

def getPosition(sender,data,userdata):
    """Retrieve positional information from the active stage

    Args:
        sender(dpg object): the calling function
        data(list): the data sent in from the sender 
        userdata (list):the data sent in from the  [0position,1sstatus,2stage,3units]
    """
    stage = dpg.get_value(userdata[2])
    stageSelection(stage)
    dpg.set_value(userdata[1],stage+" Stage status: Position Query")
    
    position= callPosition()
    position= float(re.findall(r"[-+]?\d*\.\d+|[-+]?\d+", str(position))[0])
    units= dpg.get_value(userdata[3])
    position= (position/conversion[stage][units])*-2
    
    dpg.set_value(userdata[0],stage+' current Position: '+str(position))
    dpg.set_value(userdata[1],"Stage status: inactive")
    

def moveStage(sender,data,userdata):
    """Move the currently active stage to a new position

    Args:
        sender(dpg object): the calling function
        data(list): the data sent in from the sender 
        userdata (list):the data sent in from the  [0destination,1position,2stage
                                                    ,3units,4speed,5sunits,6sstatus]
    """
    stage= dpg.get_value(userdata[2])
    stageSelection(stage)
    dpg.set_value(userdata[6],"Stage status: Moving")
    speed = dpg.get_value(userdata[4])
    sunit = dpg.get_value(userdata[5])
    speed = speed*conversion[stage][sunit]
    setSpeed(speed)
    dest= dpg.get_value(userdata[0])
    unit =  dpg.get_value(userdata[3])
    
    position =dest*conversion[stage][unit]/-2
    moveTo(position)
    endpoint = callPosition()
    endpoint = float(re.findall(r"[-+]?\d*\.\d+|[-+]?\d+", str(endpoint))[0])
    endpoint=(endpoint/conversion[stage][unit])*-2
    dpg.set_value(userdata[1],"Current Position: "+str(endpoint))
    dpg.set_value(userdata[6],"Stage status: inactive") 

def handlelog(start,end,num,unit):
    """handle the generation of appropriate log space based on given parameter
    Args: 
        start: the initial value for the space (if negative a sign flip is applied making a space porportional to max value) 
        end: the final value for the space (if negative a sign flip is applied )
        num: the number of total spaces  
    Returns:
        logspace bound by start and end with num points 
    """
    unitmin = { 'fs':10,
                'ps':.01,
                'um':3,
                'mm':.003,
                'ct':430}
    boundary = np.log10(unitmin[unit])
    if(start==end):
        combinedspace=np.ones(num)*start
    elif((start<0)^(end<0)):
        print('partial negative')
        spacelength = np.abs(end-start)
        startsteps=  int(np.floor(num*np.abs(start)/spacelength))
        endsteps= int(num-startsteps-1)
        if((start<0)&(end!=0)): 
            print("regular broken space")#
            startspace= -np.logspace(np.log10(np.abs(start)),boundary,startsteps)
            endspace = np.logspace(boundary,np.log10(np.abs(end)),endsteps)
            combinedspace = np.append(startspace,0)
            combinedspace = np.append(combinedspace,endspace)
        elif((end<0)&(start!=0)):
            print("reversed broken space")#
            startspace= np.logspace(np.log10(np.abs(start)),boundary,startsteps)
            endspace = -np.logspace(boundary,np.log10(np.abs(end)),endsteps)
            combinedspace = np.append(startspace,0)
            combinedspace = np.append(combinedspace,endspace)
        elif(start == 0 ):
            print('negative zero start space')
            combinedspace = -np.logspace(boundary,np.log10(np.abs(end)),num)
            combinedspace = np.append(0,combinedspace)
        elif(end   == 0 ):
            print('negative zero end space')
            combinedspace = -np.logspace(np.log10(np.abs(start)),boundary,num)
            combinedspace = np.append(combinedspace,0)
    elif(start==0):
        print('positive zero start space')
        combinedspace = np.logspace(boundary,np.log10(np.abs(end)),num-1)
        combinedspace = np.append(0,combinedspace)
    elif(end==0):
        print('positive zero end space')
        combinedspace= np.logspace(np.log10(np.abs(start)),boundary,num-1)
        combinedspace= np.append(combinedspace,0)
    elif((start<0)&(end<0)):
        print("negative consecutive space")
        combinedspace= -np.logspace(np.log10(np.abs(start)),np.log10(np.abs(end)),num)
    elif((start>0)&(end>0)):
        print("positive consecutive space")
        combinedspace= np.logspace(np.log10(np.abs(start)),np.log10(np.abs(end)),num)
    return combinedspace
def runHFWM(sender,data,userdata):
    """Run a rasterization of two stages while recording data read from 
    the lock-in amplifier 
    Args: 
        sender(dpg function data): the function information covering the 
        settings of the calling function 
        data (data variable): an arbitrary data variable containing the data 
        generated by the calling function 
        userdata(list): a list variables set in optionally from the user in
        this case it has the values:
        [0] stage a id [1] stage b id [2]speed stage a 
        [3] speed for stage b [4] speed unit stage a 
        [5]speed unit stage b [6]start point for stage a 
        [7] start point stage b [8] endpoint for stage a 
        [9]enpoint stage b [10] steps for stage a [11]steps for stage b 
        [12] distance units stage a [13] distance unit stage b
        [14] progress bar [15] texture location for plotting image
        [16] storage variable for mesh data[17] integration time 
        [18] indicator for time elapsed [19] radio option for measurement space """
    #connect to zurich instruments lock in amplifier

    
    #set up the variables in a readable format
    stagea = dpg.get_value(userdata[0])
    stageb = dpg.get_value(userdata[1])
    speeda = dpg.get_value(userdata[2])
    speedb = dpg.get_value(userdata[3])
    sunita = dpg.get_value(userdata[4])
    sunitb = dpg.get_value(userdata[5])
    starta = dpg.get_value(userdata[6])
    startb = dpg.get_value(userdata[7])
    enda = dpg.get_value(userdata[8])
    endb = dpg.get_value(userdata[9])
    stepsa = dpg.get_value(userdata[10])
    stepsb = dpg.get_value(userdata[11])
    unita = dpg.get_value(userdata[12])
    unitb = dpg.get_value(userdata[13])
    space = dpg.get_value(userdata[19])
    
    #prime stage a 
    stageSelection(stagea)
    speeda = speeda*conversion[stagea][sunita]
    setSpeed(speeda)
    
    #prime stage b
    stageSelection(stageb)
    speedb = speedb*conversion[stageb][sunitb]
    setSpeed(speedb)
    
    #setting up the external widget locations  
    pb = userdata[14]
    textureid = userdata[15]
    timemonitor= userdata[18]

    #set integration time 

    #generate xy space for raster
    print(space)
    if(space == "line space"):
        x= np.linspace(starta,enda,int(stepsa))
        y= np.linspace(startb,endb,int(stepsb))
    elif(space=="log space"):
        x= handlelog(starta,enda,int(stepsa),unita)
        y= handlelog(startb,endb,int(stepsb),unitb)
    #grab global storage variable for z  
    global z

    #set up temparary storage variable for z with dimensions along xy  
    ztemp=np.zeros((int(stepsa),int(stepsb)))
    yaxis=np.flip(y)
    ztemp= np.append(ztemp,[yaxis],axis=0)
    ztemp=np.flipud(ztemp)
    xaxis =np.append(0,x)[np.newaxis]
    xaxis = xaxis.transpose()
    ztemp= np.append(ztemp,xaxis,axis=1)
    ztemp=np.fliplr(ztemp)
    
    #Set up figure 
    fig,ax =plt.subplots(layout='compressed')
    fig.set_dpi(100)
    fig.set_figwidth(5.8)
    fig.set_figheight(5.8)
    ax.set_xlabel('stage '+stageb+' delay '+'['+unitb+']')
    ax.set_ylabel('stage '+stagea+' delay '+'['+unita+']')
    tstart = t.time()
    for i,xi in enumerate(x):
        #select and move stage a to new x positition
        stageSelection(stagea)
        dest= xi*conversion[stagea][unita]/-2
        moveTo(dest)
        #print('maybe a subscribe issue ')

        #print('not a subscribe issue ')
        for j,yi in enumerate(y):
            dpg.set_value(pb,(i*stepsb+j)/(stepsa*stepsb)) 
            if(j==0):
                #select stage b
                stageSelection(stageb)
            dest= yi*conversion[stageb][unitb]/-2
            moveTo(dest)
            #replace with TCSPC Code ztemp[i+1,j+1] = np.mean((daqdata(device,session,inttime)))
        
        if( i % 1 == 0 ):
            if((stepsa==1)|(stepsb==1)):
                taxis = 0
                if(stepsa == 1):
                    taxis=y
                    r = np.transpose(ztemp[1:,1:])
                if(stepsb == 1):
                    taxis=x
                    r=ztemp[1:,1:]
                if(i==0):
                    line, = ax.plot(taxis,r)
                    ax.set_ylim(ymax=np.max(ztemp[1:,1:])+.1*np.max(ztemp[1:,1:]))
                else:
                    line.set_ydata(r)
                    ax.set_ylim(ymax=np.max(ztemp[1:,1:]))
            else:
                neg = ax.imshow(ztemp[1:,1:],extent=[startb,endb,enda,starta],aspect=np.abs((startb-endb)/(starta-enda)))
                if(i==0):
                    cbar=fig.colorbar(neg,ax=ax)
                neg.set_clim(np.min(ztemp[1:,1:]),np.max(ztemp[1:,1:]))
            fig.canvas.draw()
            data = np.frombuffer(fig.canvas.buffer_rgba(),dtype=np.uint8)
            dpg.set_value(textureid,data/255)
            runtime = t.time()
            #print('maybe time counter issue')
            if(i%3==2):
                timepassed = (runtime-tstart)/60
                timeleft = (runtime-tstart)/(i*stepsb+j)*(stepsa*stepsb-i*stepsb-j)/60 
                outputstr="{timepassed:.2f} minutes complete, {timeleft:.2f} minutes remaining".format(timepassed=timepassed,timeleft=timeleft)
                dpg.set_value(timemonitor,outputstr)
            #print('not time counter issue')            
        
        z=ztemp
    if((stepsa==1)|(stepsb==1)):
        line.set_ydata(ztemp[1:,1:])
        ax.set_ylim(ymax=np.max(ztemp[1:,1:]))
    else:
        ax.imshow(ztemp[1:,1:],extent=[startb,endb,enda,starta],aspect=np.abs((startb-endb)/(starta-enda)))
        neg.set_clim(np.min(ztemp[1:,1:]),np.max(ztemp[1:,1:]))
    fig.canvas.draw()
    data = np.frombuffer(fig.canvas.buffer_rgba(),dtype=np.uint8)
    dpg.set_value(textureid,data/255)
    print('done')

def savefile(sender,data,userdata):
    global z
    print('saving file to: ', data['file_path_name'])
    np.savetxt(data['file_path_name'],z,delimiter=';')    
def savecanceled(sender,data,userdata):
    print('save Attempt canceled')
    print(data)